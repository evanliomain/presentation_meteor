'use strict';

var path = require('path');

var _ = require('lodash');
var multimatch = require('multimatch');
var uuid = require('uuid');

var $ = require('../plugins');
var error = require('../error');

function handleChanges(options, config, src) {
  if (_.isEmpty(config.$changed) || !src)
    return src;

  if (options.onChange === 'none')
    return [];

  if (options.onChange === 'all')
    return src;

  var changed = _(config.$changed)
    .filter(function(event) {
      return event.type !== 'deleted';
    })
    .map(function(event) {
      return path.relative(process.cwd(), event.path);
    })
    .value()
  ;

  var oldsrc = src;
  src = multimatch(changed, src);

  if (!src.length && options.onChange === 'allIfEmpty')
    return oldsrc;

  return src;
}

module.exports = function $initSrc(options, sources) {
  if (arguments.length < 2) {
    sources = options;
    options = {};
  }
  sources = sources || [];
  _.defaults(options, {failOnNoMatch: true});

  var knownGlobs = [];

  var cacheUuid = uuid.v4();

  return this.$decorate(function $src(parent, config) {
    var src = sources;
    if (_.isFunction(src))
      src = src.call(config) || [];

    var globs = src;

    if (!_.any(knownGlobs, _.partial(_.isEqual, src))) {
      knownGlobs.push(src);
      config.$shouldEmit.push(src);
    }
    else if (!_.any(config.$shouldEmit, _.partial(_.isEqual, src)))
      src = handleChanges(options, config, src);

    if (options.failOnNoMatch && !config.$changed && _.isEmpty(src))
      throw new error.GlouError('Pattern `' +
        (_.isFunction(sources) ? 'function ' + (sources.name || '(anonymous)') : sources) +
        "' does not match anything");

    return {
      stream: $.multipipe(
        parent,
        $.addSrc(options, src),
        options.base ?
          $.noop() :
          $.multipipe($.restoreBase(cacheUuid, globs), $.noop())
      ),
      config: config,
    };
  });
};
