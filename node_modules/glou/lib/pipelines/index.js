'use strict';

var _ = require('lodash');

var Config = require('../config');
var error = require('../error');

var pipelines = _.extend(module.exports, {
  // Instanciate the current step for internal use
  $run: function $run(config) {
    var parent = this.$parent ? this.$parent(config) : {config: config};

    // Call our function (all pipelines are functions)
    return this.call(this, parent.stream, parent.config);
  },

  // Main function of glou
  // Takes what should be executed to create the current step and make it properly chainable, handling context & such.
  // `this` shall be `null` in this function if we are creating a starting step
  $decorate: function $decorate($fn) {
    // Function that will execute the new step if called and reexpose glou methods on it
    var $decorated = function $decorated(config) {
      // If this is a Config then it is the parent's pipeline, merge it with provided config
      // Otherwise create a new Config object
      config = this && this instanceof Config ?
        this.merge(config) :
        new Config(config)
      ;

      if (!config.$reemiter)
        config.$reemiter = new error.Reemiter();

      // Ultimately, instanciate the current step
      return $fn.$run(config).stream;
    };

    // Add all glou methods to the function
    _.each(pipelines, function(pipeline, key) {
      $fn[key] = pipeline.bind($fn);
      if (key[0] !== '$')
        $decorated[key] = $fn[key];
    });

    // Parent of the future new step is our `$run` function
    $fn.$parent = this && this.$run;

    return $decorated;
  },

  // get all standard methods
  src: require('./src'),
  dest: require('./dest'),
  configure: require('./configure'),
  pipe: require('./pipe'),
  parallel: require('./parallel'),
  serie: require('./serie'),
  remember: require('./remember'),
  prepend: require('./insert').prepend,
  append: require('./insert').append,
});
